Directory Structure:
===================
root
    |- build-local.ps1
    |- build-version.ps1
    |- build.ps1
    |- cmd
        |- benchmark_test.go
        |- integration_test.go
        |- root.go
        |- root_test.go
    |- main.go

The Source File Contents Are Listed Below, Organized by Extension Under the Respective Heading

.GO Files:
==========

// cmd\benchmark_test.go
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"
)

func BenchmarkExpandBraces(b *testing.B) {
	pattern := "*.{go,js,py,java,cpp,c,h,hpp}"
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		expandBraces(pattern)
	}
}

func BenchmarkProcessFilters(b *testing.B) {
	exclude := []string{"*.{log,tmp,bak}", "node_modules", ".git"}
	include := []string{"*.{go,js,py,java}", "*.md"}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		processFilters(exclude, include)
	}
}

func BenchmarkFindMatchingFiles(b *testing.B) {
	tempDir, err := os.MkdirTemp("", "benchmark_test")
	if err != nil {
		b.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	for i := 0; i < 100; i++ {
		for _, ext := range []string{".go", ".js", ".py", ".md", ".log"} {
			dir := filepath.Join(tempDir, "subdir", "nested")
			err := os.MkdirAll(dir, 0755)
			if err != nil {
				b.Fatal(err)
			}
			file := filepath.Join(dir, fmt.Sprintf("file%d%s", i, ext))
			err = os.WriteFile(file, []byte("content"), 0644)
			if err != nil {
				b.Fatal(err)
			}
		}
	}
	filters := processFilters([]string{"*.log"}, []string{"*.go"})
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := findMatchingFiles(tempDir, filters)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkBuildTreeOutput(b *testing.B) {
	tempDir, err := os.MkdirTemp("", "tree_benchmark")
	if err != nil {
		b.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	var paths []string
	for i := 0; i < 50; i++ {
		for j := 0; j < 5; j++ {
			dir := filepath.Join(tempDir, fmt.Sprintf("dir%d", i))
			err := os.MkdirAll(dir, 0755)
			if err != nil {
				b.Fatal(err)
			}
			file := filepath.Join(dir, fmt.Sprintf("file%d.go", j))
			err = os.WriteFile(file, []byte("content"), 0644)
			if err != nil {
				b.Fatal(err)
			}
			paths = append(paths, file)
		}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		buildTreeOutput(tempDir, paths)
	}
}


// cmd\integration_test.go
package cmd

import (
	"os"
	"path/filepath"
	"testing"
)

// setupTestDirectory creates a test directory structure
func setupTestDirectory(t *testing.T) string {
	tempDir, err := os.MkdirTemp("", "wintree_integration_test")
	if err != nil {
		t.Fatal(err)
	}

	// Create a complex directory structure
	structure := map[string]string{
		"main.go":                       "package main",
		"README.md":                     "# Test Project",
		"go.mod":                        "module test",
		".gitignore":                    "*.log",
		"src/app.go":                    "package src",
		"src/utils.js":                  "// utils",
		"src/styles.css":                "body {}",
		"tests/main_test.go":            "package tests",
		"tests/app_test.js":             "// test",
		"docs/api.md":                   "# API",
		"docs/guide.txt":                "Guide",
		"logs/app.log":                  "log entry",
		"logs/error.log":                "error",
		"node_modules/package/index.js": "// package",
		"build/output.bin":              "binary",
		"temp/cache.tmp":                "cache",
		".vscode/settings.json":         "{}",
		"hidden/.secret":                "secret",
	}

	for filePath, content := range structure {
		fullPath := filepath.Join(tempDir, filePath)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatal(err)
		}
		err = os.WriteFile(fullPath, []byte(content), 0644)
		if err != nil {
			t.Fatal(err)
		}
	}

	return tempDir
}

func TestFindMatchingFiles_IncludeMode(t *testing.T) {
	testDir := setupTestDirectory(t)
	defer os.RemoveAll(testDir)

	tests := []struct {
		name            string
		includePatterns []string
		expectedFiles   []string
		unexpectedFiles []string
	}{
		{
			name:            "include go files",
			includePatterns: []string{"*.go"},
			expectedFiles:   []string{"main.go", "app.go", "main_test.go"},
			unexpectedFiles: []string{"utils.js", "README.md"},
		},
		{
			name:            "include with brace expansion",
			includePatterns: []string{"*.{go,js}"},
			expectedFiles:   []string{"main.go", "app.go", "utils.js", "main_test.go", "app_test.js", "index.js"},
			unexpectedFiles: []string{"README.md", "styles.css"},
		},
		{
			name:            "include markdown files",
			includePatterns: []string{"*.md"},
			expectedFiles:   []string{"README.md", "api.md"},
			unexpectedFiles: []string{"main.go", "guide.txt"},
		},
		{
			name:            "include directory",
			includePatterns: []string{"docs"},
			expectedFiles:   []string{"api.md", "guide.txt"},
			unexpectedFiles: []string{"main.go", "app.go"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			filters := processFilters([]string{}, tt.includePatterns)
			matchingFiles, err := findMatchingFiles(testDir, filters)
			if err != nil {
				t.Fatalf("findMatchingFiles() error = %v", err)
			}

			// Convert to set of basenames for easier checking
			fileNames := make(map[string]bool)
			for _, file := range matchingFiles {
				fileNames[filepath.Base(file)] = true
			}

			for _, expected := range tt.expectedFiles {
				if !fileNames[expected] {
					t.Errorf("Expected file %q not found in results", expected)
				}
			}

			for _, unexpected := range tt.unexpectedFiles {
				if fileNames[unexpected] {
					t.Errorf("Unexpected file %q found in results", unexpected)
				}
			}
		})
	}
}

func TestFindMatchingFiles_ExcludeMode(t *testing.T) {
	testDir := setupTestDirectory(t)
	defer os.RemoveAll(testDir)

	tests := []struct {
		name            string
		excludePatterns []string
		expectedFiles   []string
		unexpectedFiles []string
	}{
		{
			name:            "exclude log files",
			excludePatterns: []string{"*.log"},
			expectedFiles:   []string{"main.go", "README.md"},
			unexpectedFiles: []string{"app.log", "error.log"},
		},
		{
			name:            "exclude with brace expansion",
			excludePatterns: []string{"*.{log,tmp}"},
			expectedFiles:   []string{"main.go", "README.md"},
			unexpectedFiles: []string{"app.log", "cache.tmp"},
		},
		{
			name:            "exclude directories",
			excludePatterns: []string{"node_modules", "build"},
			expectedFiles:   []string{"main.go", "README.md"},
			unexpectedFiles: []string{"index.js", "output.bin"},
		},
		{
			name:            "exclude hidden files",
			excludePatterns: []string{".*"},
			expectedFiles:   []string{"main.go", "README.md"},
			unexpectedFiles: []string{".gitignore", "settings.json", ".secret"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			filters := processFilters(tt.excludePatterns, []string{})
			matchingFiles, err := findMatchingFiles(testDir, filters)
			if err != nil {
				t.Fatalf("findMatchingFiles() error = %v", err)
			}

			// Convert to set of basenames for easier checking
			fileNames := make(map[string]bool)
			for _, file := range matchingFiles {
				fileNames[filepath.Base(file)] = true
			}

			for _, expected := range tt.expectedFiles {
				if !fileNames[expected] {
					t.Errorf("Expected file %q not found in results", expected)
				}
			}

			for _, unexpected := range tt.unexpectedFiles {
				if fileNames[unexpected] {
					t.Errorf("Unexpected file %q found in results", unexpected)
				}
			}
		})
	}
}

func TestFindMatchingFiles_CombinedMode(t *testing.T) {
	testDir := setupTestDirectory(t)
	defer os.RemoveAll(testDir)

	// Test include + exclude combination
	filters := processFilters(
		[]string{"*_test.go"}, // exclude test files
		[]string{"*.go"},      // include only go files
	)

	matchingFiles, err := findMatchingFiles(testDir, filters)
	if err != nil {
		t.Fatalf("findMatchingFiles() error = %v", err)
	}

	fileNames := make(map[string]bool)
	for _, file := range matchingFiles {
		fileNames[filepath.Base(file)] = true
	}

	// Should include go files but not test files
	if !fileNames["main.go"] {
		t.Error("Expected main.go to be included")
	}
	if !fileNames["app.go"] {
		t.Error("Expected app.go to be included")
	}
	if fileNames["main_test.go"] {
		t.Error("main_test.go should be excluded")
	}
	if fileNames["utils.js"] {
		t.Error("utils.js should not be included")
	}
}

func TestEdgeCases(t *testing.T) {
	t.Run("empty directory", func(t *testing.T) {
		tempDir, err := os.MkdirTemp("", "empty_test")
		if err != nil {
			t.Fatal(err)
		}
		defer os.RemoveAll(tempDir)

		filters := processFilters([]string{}, []string{})
		matchingFiles, err := findMatchingFiles(tempDir, filters)
		if err != nil {
			t.Fatalf("findMatchingFiles() error = %v", err)
		}

		if len(matchingFiles) != 0 {
			t.Errorf("Expected 0 files in empty directory, got %d", len(matchingFiles))
		}
	})

	t.Run("nonexistent directory", func(t *testing.T) {
		_, err := findMatchingFiles("/nonexistent/path", filter{})
		if err == nil {
			t.Error("Expected error for nonexistent directory")
		}
	})

	t.Run("include mode with no matches", func(t *testing.T) {
		testDir := setupTestDirectory(t)
		defer os.RemoveAll(testDir)

		filters := processFilters([]string{}, []string{"*.nonexistent"})
		matchingFiles, err := findMatchingFiles(testDir, filters)
		if err != nil {
			t.Fatalf("findMatchingFiles() error = %v", err)
		}

		if len(matchingFiles) != 0 {
			t.Errorf("Expected 0 files for nonexistent pattern, got %d", len(matchingFiles))
		}
	})
}

func TestFindMatchingFiles_DepthMode(t *testing.T) {
	testDir := setupTestDirectory(t)
	defer os.RemoveAll(testDir)

	tests := []struct {
		name          string
		depth         int
		expectedFiles []string
		unexpected    []string
	}{
		{
			name:          "depth 0",
			depth:         0,
			expectedFiles: []string{"main.go", "README.md", "go.mod", ".gitignore"},
			unexpected:    []string{"app.go", "main_test.go", "api.md"},
		},
		{
			name:          "depth 1",
			depth:         1,
			expectedFiles: []string{"main.go", "app.go", "utils.js", "main_test.go", "api.md", "settings.json"},
			unexpected:    []string{"index.js"}, // This is at depth 2
		},
		{
			name:          "unlimited depth",
			depth:         -1, // -1 means unlimited
			expectedFiles: []string{"main.go", "app.go", "index.js", "output.bin"},
			unexpected:    []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set the global maxDepth for the test
			maxDepth = tt.depth

		 filters := processFilters([]string{}, []string{}) // No filters, just depth
			matchingFiles, err := findMatchingFiles(testDir, filters)
			if err != nil {
				t.Fatalf("findMatchingFiles() with depth %d error = %v", tt.depth, err)
			}

			// Convert to set of basenames for easier checking
			fileNames := make(map[string]bool)
			for _, file := range matchingFiles {
				fileNames[filepath.Base(file)] = true
			}

			for _, expected := range tt.expectedFiles {
				if !fileNames[expected] {
					t.Errorf("Depth %d: Expected file %q not found", tt.depth, expected)
				}
			}

			for _, unexpectedFile := range tt.unexpected {
				if fileNames[unexpectedFile] {
					t.Errorf("Depth %d: Unexpected file %q found", tt.depth, unexpectedFile)
				}
			}
		})
	}
	// Reset maxDepth after tests to avoid affecting other tests
	maxDepth = -1
}


// cmd\root.go
/*
Copyright © 2025 Maxim Dribny <mdribnyi@gmail.com>
*/
package cmd

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/atotto/clipboard"
	"github.com/spf13/cobra"

	"regexp"
)

// Version information
var (
	Version   = "dev"
	Commit    = "unknown"
	BuildDate = "unknown"
)

var (
	excludePatterns  []string
	includePatterns  []string
	outputFile       string
	copyToClipboard  bool
	showPatterns     bool
	showVersion      bool
	useSmartDefaults bool
	maxDepth         int
)

type filter struct {
	excludeGlobs []string
	includeGlobs []string
}

var rootCmd = &cobra.Command{
	Use:   "wintree [path]",
	Short: "A modern, cross-platform tree command.",
	Long: `wintree is a simple, intuitive, and easy-to-use alternative to the
built-in tree commands on Windows and other operating systems.

It allows for advanced filtering with inclusion and exclusion patterns
and can output to the terminal, a file, or the system clipboard.`,
	Args: cobra.MaximumNArgs(1), // We expect at most one argument: the path.
	RunE: func(cmd *cobra.Command, args []string) error {
		// Check if the user wants version info
		if showVersion {
			printVersionInfo()
			return nil
		}

		// Check if the user wants pattern help
		if showPatterns {
			printPatternHelp()
			return nil
		}

		// 1. Setup - Find Start Path
		startPath := "."
		if len(args) > 0 {
			startPath = args[0]
		}
		startPath, err := filepath.Abs(startPath)
		if err != nil {
			return fmt.Errorf("invalid starting path: %w", err)
		}

		// Apply smart defaults if requested
		if useSmartDefaults {
			applySmartDefaults(startPath)
		}

		filters := processFilters(excludePatterns, includePatterns)

		// 2. Find all matching files
		matchingFiles, err := findMatchingFiles(startPath, filters)
		if err != nil {
			return fmt.Errorf("error finding files: %w", err)
		}

		// If in include mode and no files were found, nothing to do
		if len(filters.includeGlobs) > 0 && len(matchingFiles) == 0 {
			fmt.Println("No files found matching the given patterns.")
			return nil
		}

		// 3. Build the tree output from the list of files
		finalOutput := buildTreeOutput(startPath, matchingFiles)

		// 4. Handle final output
		if copyToClipboard {
			if err := clipboard.WriteAll(finalOutput); err != nil {
				return fmt.Errorf("failed to copy to clipboard: %w", err)
			}
			fmt.Println("Output copied to clipboard.")
		}
		if outputFile != "" {
			if err := os.WriteFile(outputFile, []byte(finalOutput), 0644); err != nil {
				return fmt.Errorf("failed to write to output file: %w", err)
			}
			fmt.Printf("Output written to %s\n", outputFile)
		}
		if !copyToClipboard && outputFile == "" {
			fmt.Print(finalOutput)
		}

		return nil
	},
}

// expandBraces expands brace patterns like "*.{go,js}" into ["*.go", "*.js"]
func expandBraces(pattern string) []string {
	braceRegex := regexp.MustCompile(`\{([^}]*)\}`)
	matches := braceRegex.FindStringSubmatch(pattern)

	if len(matches) < 2 {
		return []string{pattern} // No braces found
	}

	// Handle empty braces case - "{}"
	if matches[1] == "" {
		return []string{strings.Replace(pattern, matches[0], "", 1)}
	}

	options := strings.Split(matches[1], ",")
	var expanded []string

	for _, option := range options {
		newPattern := strings.Replace(pattern, matches[0], strings.TrimSpace(option), 1)
		expanded = append(expanded, newPattern)
	}

	return expanded
}

func processFilters(exclude, include []string) filter {
	var expandedExclude, expandedInclude []string

	// Expand braces for exclude patterns
	for _, pattern := range exclude {
		expandedExclude = append(expandedExclude, expandBraces(pattern)...)
	}

	// Expand braces for include patterns
	for _, pattern := range include {
		expandedInclude = append(expandedInclude, expandBraces(pattern)...)
	}

	return filter{
		excludeGlobs: expandedExclude,
		includeGlobs: expandedInclude,
	}
}

// findMatchingFiles handles directory-based includes and file-based glob includes.
func findMatchingFiles(root string, f filter) ([]string, error) {
	var matchingPaths []string
	isIncludeMode := len(f.includeGlobs) > 0

	walkErr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Depth check (before exclusion / inclusion)
		if d.IsDir() && path != root {
			relPath, err := filepath.Rel(root, path)
			if err != nil {
				return err
			}

			// Depth 0 is the root's immediate children
			depth := strings.Count(relPath, string(filepath.Separator))

			// if maxdepth is set and the current depth exceeds it, skip this directory
			if maxDepth != -1 && depth > maxDepth {
				return fs.SkipDir
			}
		}

		// --- Exclusion Logic (runs first) ---
		entryName := d.Name()
		for _, pattern := range f.excludeGlobs {
			matched, _ := filepath.Match(pattern, entryName)
			if matched {
				if d.IsDir() {
					if path == root {
						return nil
					}
					return fs.SkipDir
				}
				return nil
			}
		}

		// If not in include mode, add all non-directory files.
		if !isIncludeMode {
			if !d.IsDir() {
				matchingPaths = append(matchingPaths, path)
			}
			return nil
		}

		// In include mode, we must match files or directories explicitly.
		// Case 1: A directory is an exact match for an include pattern.
		// If so, we do a sub-walk and add all its files.
		if d.IsDir() {
			for _, pattern := range f.includeGlobs {
				// Don't glob, use exact match for directory inclusion.
				if d.Name() == pattern {
					// This directory is explicitly included. Walk it and add all files within.
					subWalkErr := filepath.WalkDir(path, func(subPath string, subD fs.DirEntry, _ error) error {
						if !subD.IsDir() {
							// Check if this sub-file is excluded.
							isExcluded := false
							for _, excludePattern := range f.excludeGlobs {
								if matched, _ := filepath.Match(excludePattern, subD.Name()); matched {
									isExcluded = true
									break
								}
							}
							if !isExcluded {
								matchingPaths = append(matchingPaths, subPath)
							}
						}
						return nil
					})
					if subWalkErr != nil {
						return subWalkErr
					}
					// We've processed this directory, so skip it in the main walk.
					return fs.SkipDir
				}
			}
		}

		// Case 2: A file matches a glob-style include pattern.
		if !d.IsDir() {
			for _, pattern := range f.includeGlobs {
				if matched, _ := filepath.Match(pattern, d.Name()); matched {
					matchingPaths = append(matchingPaths, path)
					break
				}
			}
		}

		return nil
	})

	return matchingPaths, walkErr
}

// Construct the tree output as a string
func buildTreeOutput(root string, paths []string) string {
	if len(paths) == 0 {
		return filepath.Base(root) + "\n"
	}

	// Initialize a map to hold all nodes (directories and files)
	nodes := make(map[string]bool)
	// Always include the root directory
	nodes[root] = true

	// Add all files and their parent directories to the nodes map
	for _, path := range paths {
		// Skip paths outside the root directory
		if !strings.HasPrefix(path, root) {
			continue
		}

		// Add the file itself
		nodes[path] = true

		// Add all parent directories of the path to the nodes map as well
		dir := filepath.Dir(path)
		for dir != root && dir != "." && dir != "/" {
			nodes[dir] = true
			dir = filepath.Dir(dir)
		}
	}

	// Convert to a sorted slice for consistent output
	sortedNodes := make([]string, 0, len(nodes))
	for nodePath := range nodes {
		sortedNodes = append(sortedNodes, nodePath)
	}
	sort.Strings(sortedNodes)

	// Generate the tree output
	var output strings.Builder
	// Start with the root directory name
	output.WriteString(filepath.Base(root) + "\n")

	// A map to track which directory levels have more items, for drawing the tree with '|'
	lastInDir := make(map[int]bool)

	// Process each node (skipping the root which we already output)
	for i := 1; i < len(sortedNodes); i++ {
		path := sortedNodes[i]
		// Get relative path from root
		relPath, err := filepath.Rel(root, path)
		if err != nil {
			continue
		}

		// Calculate the depth of this node relative to root
		parts := strings.Split(relPath, string(filepath.Separator))
		depth := len(parts) - 1

		// Check if this is the last entry at its depth or in its parent directory
		isLast := true
		if i < len(sortedNodes)-1 {
			nextPath := sortedNodes[i+1]
			nextRelPath, err := filepath.Rel(root, nextPath)
			if err == nil {
				nextParts := strings.Split(nextRelPath, string(filepath.Separator))
				nextDepth := len(nextParts) - 1

				// If next item is at same depth and has same parent, this isn't last
				if nextDepth == depth && len(parts) > 1 && len(nextParts) > 1 &&
					parts[0] == nextParts[0] {
					isLast = false
				}
			}
		}
		lastInDir[depth] = isLast

		// Print indentation
		for j := 0; j < depth; j++ {
			if lastInDir[j] {
				output.WriteString("    ")
			} else {
				output.WriteString("│   ")
			}
		}

		// Print branch prefix
		if isLast {
			output.WriteString("└── ")
		} else {
			output.WriteString("├── ")
		}

		output.WriteString(filepath.Base(path) + "\n")
	}

	return output.String()
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	rootCmd.Flags().StringSliceVarP(&excludePatterns, "exclude", "e", []string{}, "Glob patterns to exclude (e.g., .git, *.log, node_modules)")
	rootCmd.Flags().StringSliceVarP(&includePatterns, "include", "i", []string{}, "Glob patterns to include (e.g., .git, *.go, *.md)")
	rootCmd.Flags().StringVarP(&outputFile, "out", "o", "", "Output to a file instead of the console")
	rootCmd.Flags().BoolVarP(&copyToClipboard, "copy", "c", false, "Copy the output to the system clipboard")
	rootCmd.Flags().BoolVarP(&showPatterns, "show-patterns", "p", false, "Show a guide for using glob patterns")
	rootCmd.Flags().BoolVarP(&showVersion, "version", "v", false, "Show version information")
	rootCmd.Flags().BoolVarP(&useSmartDefaults, "smart-defaults", "s", false, "Apply smart defaults based on detected project type")
	rootCmd.Flags().IntVarP(&maxDepth, "depth", "d", 1, "Set the maximum depth of the directory tree to display (-1 for unlimited). (Default = 1)")
}

func printPatternHelp() {
	fmt.Print(`
GLOB PATTERN GUIDE
==================

Glob patterns are simple wildcard patterns used to match file and directory names.
Here are the most common patterns you can use with wintree:

BASIC PATTERNS:
┌─────────────┬─────────────────────────────────────────────────────────┐
│ Pattern     │ Description                                             │
├─────────────┼─────────────────────────────────────────────────────────┤
│ *           │ Matches any number of characters (except path separator)│
│ ?           │ Matches exactly one character                           │
│ [abc]       │ Matches any one of the characters a, b, or c            │
│ [a-z]       │ Matches any character from a to z                       │
│ [!abc]      │ Matches any character except a, b, or c                 │
│ **          │ Not supported                                           │
│ *.ext       │ Matches all files ending with .ext                      │
│ file*       │ Matches all files starting with 'file'                  │
│ *file*      │ Matches all files containing 'file'                     │
│ file?.txt   │ Matches file1.txt, fileA.txt, etc.                      │
│ [0-9]*      │ Matches files starting with a digit                     │
│ *.[ch]      │ Matches files ending with .c or .h                      │
│ *.{go,js}   │ Expands to *.go and *.js (Now supported!)               │
│ dir/*       │ Matches all files in 'dir' directory                    │
│ dir/**      │ Not supported; use --include "dir" for directories      │
└─────────────┴─────────────────────────────────────────────────────────┘

COMMON USE CASES:

📁 Exclude common directories:
   --exclude .git --exclude node_modules --exclude .vscode

📄 Include only specific file types:
   --include "*.go" --include "*.md" --include "*.txt"

🚫 Exclude log and temporary files:
   --exclude "*.log" --exclude "*.tmp" --exclude "*.temp"

💻 Include only source code files:
   --include "*.go" --include "*.js" --include "*.py" --include "*.java"

🔧 Exclude build and cache directories:
   --exclude target --exclude build --exclude dist --exclude .cache

EXAMPLES:

1. Show only Go files:
   wintree --include "*.go"

2. Exclude git and node_modules directories:
   wintree --exclude .git --exclude node_modules

3. Show only documentation files:
   wintree --include "*.md" --include "*.txt" --include "*.rst"

4. Exclude all hidden files and directories (starting with .):
   wintree --exclude ".*"

5. Include files starting with 'test':
   wintree --include "test*"

6. Include files ending with specific extensions:
   wintree --include "*.{go,js,py}"

7. Include files with a single character suffix:
   wintree --include "file?.txt"

8. Include files starting with a digit:
   wintree --include "[0-9]*"

9. Include C and header files:
   wintree --include "*.[ch]"

TIPS:
• You can use multiple --include and --exclude flags
• Patterns are case-sensitive on Linux/Mac, case-insensitive on Windows
• Directory names are matched exactly (no glob patterns for directories)
• File names support full glob pattern matching
• Exclusions are processed before inclusions
• Curly brace expansion (*.{go,js}) is supported

`)
}

// printVersionInfo displays version information
func printVersionInfo() {
	fmt.Printf("wintree %s\n", Version)
	fmt.Printf("  Commit: %s\n", Commit)
	fmt.Printf("  Built:  %s\n", BuildDate)
	fmt.Printf("  Platform: %s\n", "cross-platform")
}

// detectProjectType analyzes the directory to determine project type
func detectProjectType(path string) string {
	files, err := os.ReadDir(path)
	if err != nil {
		return "unknown"
	}

	for _, file := range files {
		name := file.Name()
		switch name {
		case "go.mod", "go.sum":
			return "go"
		case "package.json", "node_modules":
			return "node"
		case "requirements.txt", "pyproject.toml", "setup.py", "Pipfile":
			return "python"
		case "Cargo.toml":
			return "rust"
		case "pom.xml", "build.gradle":
			return "java"
		case "Gemfile":
			return "ruby"
		case "composer.json":
			return "php"
		case "package.swift", "Package.swift":
			return "swift"
		case "pubspec.yaml":
			return "dart"
		case "mix.exs":
			return "elixir"
		case ".gitignore":
			// Continue checking for more specific indicators
			continue
		}
	}

	// Check for common framework files
	for _, file := range files {
		name := file.Name()
		switch name {
		case "angular.json":
			return "angular"
		case "next.config.js", "next.config.mjs":
			return "nextjs"
		case "nuxt.config.js", "nuxt.config.ts":
			return "nuxtjs"
		case "gatsby-config.js":
			return "gatsby"
		case "svelte.config.js":
			return "svelte"
		case "vite.config.js", "vite.config.ts":
			return "vite"
		case "webpack.config.js":
			return "webpack"
		}
	}

	return "unknown"
}

// getSmartDefaults returns smart exclusion patterns based on project type
func getSmartDefaults(projectType string) []string {
	commonDefaults := []string{".git", ".DS_Store", "Thumbs.db"}

	switch projectType {
	case "go":
		return append(commonDefaults, "vendor", "*.exe", "*.dll", "*.so", "*.dylib")
	case "node", "angular", "nextjs", "nuxtjs", "gatsby", "svelte", "vite", "webpack":
		return append(commonDefaults, "node_modules", "dist", "build", ".next", ".nuxt", "coverage", "*.log")
	case "python":
		return append(commonDefaults, "__pycache__", "*.pyc", "*.pyo", "*.pyd", ".Python", "env", "venv", ".env", ".venv", "pip-log.txt", "pip-delete-this-directory.txt", ".coverage")
	case "rust":
		return append(commonDefaults, "target", "Cargo.lock")
	case "java":
		return append(commonDefaults, "target", "build", "*.class", "*.jar", "*.war", "*.ear")
	case "ruby":
		return append(commonDefaults, "vendor", ".bundle", "*.gem")
	case "php":
		return append(commonDefaults, "vendor", "composer.lock")
	case "swift":
		return append(commonDefaults, ".build", "Packages", "*.xcodeproj", "*.xcworkspace")
	case "dart":
		return append(commonDefaults, ".dart_tool", "build", ".packages")
	case "elixir":
		return append(commonDefaults, "_build", "deps", "*.beam")
	default:
		return append(commonDefaults, "node_modules", "target", "build", "dist", "vendor", "*.log", "*.tmp")
	}
}

// applySmartDefaults applies smart exclusion patterns based on detected project type
func applySmartDefaults(path string) {
	projectType := detectProjectType(path)
	smartDefaults := getSmartDefaults(projectType)

	// Only add defaults that aren't already in excludePatterns
	for _, defaultPattern := range smartDefaults {
		alreadyExists := false
		for _, existing := range excludePatterns {
			if existing == defaultPattern {
				alreadyExists = true
				break
			}
		}
		if !alreadyExists {
			excludePatterns = append(excludePatterns, defaultPattern)
		}
	}

	fmt.Printf("🧠 Smart defaults applied for %s project\n", projectType)
	fmt.Printf("   Excluding: %s\n", strings.Join(smartDefaults, ", "))
	fmt.Println()
}


// cmd\root_test.go
package cmd

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestExpandBraces(t *testing.T) {
	tests := []struct {
		name     string
		pattern  string
		expected []string
	}{
		{
			name:     "no braces",
			pattern:  "*.go",
			expected: []string{"*.go"},
		},
		{
			name:     "simple brace expansion",
			pattern:  "*.{go,js}",
			expected: []string{"*.go", "*.js"},
		},
		{
			name:     "multiple extensions",
			pattern:  "*.{go,js,py,java}",
			expected: []string{"*.go", "*.js", "*.py", "*.java"},
		},
		{
			name:     "with spaces",
			pattern:  "*.{go, js, py}",
			expected: []string{"*.go", "*.js", "*.py"},
		},
		{
			name:     "directory names",
			pattern:  "{src,test,docs}",
			expected: []string{"src", "test", "docs"},
		},
		{
			name:     "complex pattern",
			pattern:  "test*.{go,js}",
			expected: []string{"test*.go", "test*.js"},
		},
		{
			name:     "empty braces",
			pattern:  "*.{}",
			expected: []string{"*."},
		},
		{
			name:     "single option",
			pattern:  "*.{go}",
			expected: []string{"*.go"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := expandBraces(tt.pattern)
			if len(result) != len(tt.expected) {
				t.Errorf("expandBraces(%q) returned %d items, expected %d", tt.pattern, len(result), len(tt.expected))
				return
			}
			for i, expected := range tt.expected {
				if result[i] != expected {
					t.Errorf("expandBraces(%q) returned %q, expected %q", tt.pattern, result[i], expected)
				}
			}
		})
	}
}

func TestProcessFilters(t *testing.T) {
	tests := []struct {
		name            string
		exclude         []string
		include         []string
		expectedExclude []string
		expectedInclude []string
	}{
		{
			name:            "no patterns",
			exclude:         []string{},
			include:         []string{},
			expectedExclude: []string{},
			expectedInclude: []string{},
		},
		{
			name:            "simple patterns",
			exclude:         []string{"*.log"},
			include:         []string{"*.go"},
			expectedExclude: []string{"*.log"},
			expectedInclude: []string{"*.go"},
		},
		{
			name:            "brace expansion in exclude",
			exclude:         []string{"*.{log,tmp}"},
			include:         []string{"*.go"},
			expectedExclude: []string{"*.log", "*.tmp"},
			expectedInclude: []string{"*.go"},
		},
		{
			name:            "brace expansion in include",
			exclude:         []string{"*.log"},
			include:         []string{"*.{go,js}"},
			expectedExclude: []string{"*.log"},
			expectedInclude: []string{"*.go", "*.js"},
		},
		{
			name:            "multiple patterns with braces",
			exclude:         []string{"*.{log,tmp}", "node_modules"},
			include:         []string{"*.{go,js,py}", "*.md"},
			expectedExclude: []string{"*.log", "*.tmp", "node_modules"},
			expectedInclude: []string{"*.go", "*.js", "*.py", "*.md"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := processFilters(tt.exclude, tt.include)

			if len(result.excludeGlobs) != len(tt.expectedExclude) {
				t.Errorf("processFilters() excludeGlobs length = %d, expected %d",
					len(result.excludeGlobs), len(tt.expectedExclude))
			}

			if len(result.includeGlobs) != len(tt.expectedInclude) {
				t.Errorf("processFilters() includeGlobs length = %d, expected %d",
					len(result.includeGlobs), len(tt.expectedInclude))
			}

			for i, expected := range tt.expectedExclude {
				if i >= len(result.excludeGlobs) || result.excludeGlobs[i] != expected {
					t.Errorf("processFilters() excludeGlobs[%d] = %q, expected %q", i, result.excludeGlobs[i], expected)
				}
			}

			for i, expected := range tt.expectedInclude {
				if i >= len(result.includeGlobs) || result.includeGlobs[i] != expected {
					t.Errorf("processFilters() includeGlobs[%d] = %q, expected %q", i, result.includeGlobs[i], expected)
				}
			}
		})
	}
}

func TestBuildTreeOutput(t *testing.T) {
	// Create a temporary directory structure for testing
	tempDir, err := os.MkdirTemp("", "wintree_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)
	// Create test files
	testFiles := []string{
		"file1.go",
		"file2.js",
		"subdir/file3.py",
		"subdir/nested/file4.txt",
		"another/file5.md",
	}

	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatal(err)
		}
		err = os.WriteFile(fullPath, []byte("test content"), 0644)
		if err != nil {
			t.Fatal(err)
		}
	}

	// Test building tree output
	paths := make([]string, len(testFiles))
	for i, file := range testFiles {
		paths[i] = filepath.Join(tempDir, file)
	}

	output := buildTreeOutput(tempDir, paths)

	// Check that output contains expected elements
	expectedElements := []string{
		filepath.Base(tempDir), // root directory name
		"file1.go",
		"file2.js",
		"subdir",
		"file3.py",
		"nested",
		"file4.txt",
		"another",
		"file5.md",
	}

	for _, element := range expectedElements {
		if !strings.Contains(output, element) {
			t.Errorf("buildTreeOutput() missing expected element: %q", element)
		}
	}

	// Check tree characters are present
	if !strings.Contains(output, "├──") && !strings.Contains(output, "└──") {
		t.Error("buildTreeOutput() missing tree structure containers")
	}
}

func TestRootCmd(t *testing.T) {
	// Setup test directory
	tempDir, err := os.MkdirTemp("", "root_cmd_test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Create test files
	testFiles := []string{
		"file1.go",
		"file2.js",
		"file3.log",
		"subdir/file4.py",
	}

	for _, file := range testFiles {
		fullPath := filepath.Join(tempDir, file)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		if err != nil {
			t.Fatal(err)
		}
		err = os.WriteFile(fullPath, []byte("test content"), 0644)
		if err != nil {
			t.Fatal(err)
		}
	}

	// Test cases for rootCmd
	tests := []struct {
		name           string
		args           []string
		excludeFlags   []string
		includeFlags   []string
		outputFile     string
		clipboard      bool
		showPatterns   bool
		expectError    bool
		expectedOutput string
	}{
		{
			name:         "show patterns help",
			showPatterns: true,
			expectError:  false,
		},
		{
			name:        "basic tree",
			args:        []string{tempDir},
			expectError: false,
		},
		{
			name:         "include only go files",
			args:         []string{tempDir},
			includeFlags: []string{"*.go"},
			expectError:  false,
		},
		{
			name:         "exclude log files",
			args:         []string{tempDir},
			excludeFlags: []string{"*.log"},
			expectError:  false,
		},
		{
			name:         "brace expansion",
			args:         []string{tempDir},
			includeFlags: []string{"*.{go,js}"},
			expectError:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Reset flags before each test
			excludePatterns = []string{}
			includePatterns = []string{}
			outputFile = ""
			copyToClipboard = false
			showPatterns = false
			showVersion = false
			useSmartDefaults = false

			// Set up flags
			excludePatterns = tt.excludeFlags
			includePatterns = tt.includeFlags
			outputFile = tt.outputFile
			copyToClipboard = tt.clipboard
			showPatterns = tt.showPatterns

			// Capture stdout for verification
			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Execute command
			err := rootCmd.RunE(rootCmd, tt.args)

			// Restore stdout
			w.Close()
			os.Stdout = oldStdout

			var buf bytes.Buffer
			if _, err := io.Copy(&buf, r); err != nil {
				t.Errorf("failed to copy output to buffer: %v", err)
			}

			// Check error
			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			// For show patterns, verify help text is printed
			if tt.showPatterns {
				if !strings.Contains(buf.String(), "GLOB PATTERN GUIDE") {
					t.Error("expected pattern help but didn't get it")
				}
			}
		})
	}
}


// main.go
/*
Copyright © 2025 Maxim Dribny
*/
package main

import "github.com/maxdribny/wintree/cmd"

func main() {
	cmd.Execute()
}



.PS1 Files:
===========

// build-local.ps1
go build -o "$env:USERPROFILE\bin\wintree.exe" .


// build-version.ps1
# Build script with version information
# Usage: .\build-version.ps1 [version]

param(
    [string]$Version = "dev"
)

# Fetch latest tags from remote to ensure we have current information
Write-Host "🔄 Fetching latest tags from remote..." -ForegroundColor Yellow
git fetch --tags 2>$null

# Get the latest tag and suggest next version
$LatestTag = git describe --tags --abbrev=0 2>$null
if ($LatestTag -and $LatestTag -match "v(\d+)\.(\d+)\.(\d+)") {
    $Major = [int]$Matches[1]
    $Minor = [int]$Matches[2] 
    $Patch = [int]$Matches[3] + 1
    $NextPatchVersion = "v$Major.$Minor.$Patch"
    $NextMinorVersion = "v$Major.$($Minor + 1).0"
    
    Write-Host "📋 Version Information:" -ForegroundColor Cyan
    Write-Host "  Current latest: $LatestTag"
    Write-Host "  Next patch:     $NextPatchVersion"
    Write-Host "  Next minor:     $NextMinorVersion"
    Write-Host ""
} elseif ($LatestTag) {
    Write-Host "⚠️  Found tag '$LatestTag' but it doesn't follow semantic versioning" -ForegroundColor Yellow
} else {
    Write-Host "ℹ️  No version tags found in repository" -ForegroundColor Blue
}

# Interactive version selection for dev builds
if ($Version -eq "dev") {
    Write-Host "🤔 Building with version 'dev'. Consider using a proper version:" -ForegroundColor Yellow
    if ($NextPatchVersion) {
        Write-Host "   Example: .\build-version.ps1 '$NextPatchVersion'" -ForegroundColor Gray
    } else {
        Write-Host "   Example: .\build-version.ps1 'v0.1.0'" -ForegroundColor Gray
    }
    Write-Host ""
}

# Validate version format (keeping your existing validation)
if ($Version -ne "dev" -and $Version -notmatch "^v\d+\.\d+\.\d+") {
    Write-Warning "Version '$Version' doesn't follow semantic versioning (vX.Y.Z)"
    Write-Host "Continuing anyway..."
}

# Check if version already exists
if ($Version -ne "dev") {
    $ExistingTag = git tag -l $Version 2>$null
    if ($ExistingTag) {
        Write-Warning "Version tag '$Version' already exists!"
        $Confirmation = Read-Host "Continue anyway? (y/N)"
        if ($Confirmation -notmatch "^[Yy]") {
            Write-Host "Build cancelled." -ForegroundColor Red
            exit 1
        }
    }
}

$Commit = $(git rev-parse --short HEAD 2>$null)
if (-not $Commit) { $Commit = "unknown" }

$BuildDate = (Get-Date -Format "yyyy-MM-dd HH:mm:ss")

$LdFlags = "-ldflags `"-X 'github.com/maxdribny/wintree/cmd.Version=$Version' -X 'github.com/maxdribny/wintree/cmd.Commit=$Commit' -X 'github.com/maxdribny/wintree/cmd.BuildDate=$BuildDate'`""

Write-Host "🛠️  Building wintree with version information:" -ForegroundColor Green
Write-Host "  Version: $Version"
Write-Host "  Commit: $Commit"  
Write-Host "  Build Date: $BuildDate"
Write-Host ""

Invoke-Expression "go build $LdFlags -o wintree.exe ."

if ($LASTEXITCODE -eq 0) {
    Write-Host "✅ Build successful! Testing version output:" -ForegroundColor Green
    .\wintree.exe --version
    
    # Suggest creating a tag for non-dev versions
    if ($Version -ne "dev" -and -not $ExistingTag) {
        Write-Host ""
        Write-Host "💡 To create a git tag for this version, run:" -ForegroundColor Cyan
        Write-Host "   git tag $Version" -ForegroundColor Gray
        Write-Host "   git push origin $Version" -ForegroundColor Gray
    }
} else {
    Write-Host "❌ Build failed!" -ForegroundColor Red
    exit 1
}

// build.ps1
# build.ps1 - A reusable script to build and package wintree for releases.
#
# USAGE:
# From the project root directory, run:
# .\build.ps1 -Version "v0.2.0"

[CmdletBinding()]
param (
    # The version number for the release, in the format vX.Y.Z
    [Parameter(Mandatory=$true)]
    [string]$Version
)

Write-Host "🚀 Starting build process for wintree version: $Version" -ForegroundColor Cyan

# --- 1. Initial Setup and Pre-flight Checks ---
# Get the directory where this script is located (should be the project root)
$ProjectRoot = $PSScriptRoot
$DistPath = Join-Path -Path $ProjectRoot -ChildPath "dist"

# Validate the version string format to prevent errors.
if (-not ($Version -match "^v[0-9]+\.[0-9]+\.[0-9]+$")) {
    Write-Error "Invalid version format. Please use the format 'vX.Y.Z' (e.g., v0.1.0)."
    # Exit the script with an error code.
    exit 1
}

# Clean up previous builds by removing the old dist directory if it exists.
if (Test-Path $DistPath) {
    Write-Host "🧹 Cleaning up previous build artifacts..." -ForegroundColor Yellow
    Remove-Item -Path $DistPath -Recurse -Force
}

# Create a fresh, empty dist directory.
Write-Host "📦 Creating new distribution directory at: $DistPath"
New-Item -Path $DistPath -ItemType Directory | Out-Null


# --- 2. Define Build Targets ---
# An array of objects defining each platform we want to build for.
# This makes it very easy to add or remove targets in the future.
$targets = @(
    @{GOOS="windows"; GOARCH="amd64"; Suffix=".exe"}
    @{GOOS="darwin";  GOARCH="arm64";  Suffix=""}      # For Apple Silicon Macs
    @{GOOS="darwin";  GOARCH="amd64";  Suffix=""}      # For Intel Macs
    @{GOOS="linux";   GOARCH="amd64";  Suffix=""}
)


# --- 3. Build Binaries ---
Write-Host "🛠️  Building binaries for all target platforms..." -ForegroundColor Cyan
foreach ($target in $targets) {
    # Set the environment variables for cross-compilation for this loop iteration.
    $env:GOOS = $target.GOOS
    $env:GOARCH = $target.GOARCH

    # Construct the name for the output binary file.
    $BinaryName = "wintree_$($target.GOOS)_$($target.GOARCH)$($target.Suffix)"
    $OutputPath = Join-Path -Path $DistPath -ChildPath $BinaryName
    
    Write-Host "  -> Building for $($target.GOOS)/$($target.GOARCH)..."
    try {
        # The -trimpath flag makes builds reproducible, -ldflags "-s -w" strips debug info to make the binary smaller.
        go build -v -trimpath -ldflags="-s -w" -o $OutputPath .
    } catch {
        Write-Error "Build failed for $($target.GOOS)/$($target.GOARCH). Aborting script."
        exit 1
    }
}


# --- 4. Package Binaries ---
Write-Host "🗜️  Packaging binaries into .zip archives..." -ForegroundColor Cyan
# Get all the files we just created in the dist folder.
Get-ChildItem -Path $DistPath | ForEach-Object {
    $BinaryFile = $_
    
    # Construct a descriptive platform name based on GOOS and GOARCH.
    $PlatformName = if ($BinaryFile.Name -match "darwin_amd64") {
        "macos_intel"
    } elseif ($BinaryFile.Name -match "darwin_arm64") {
        "macos_silicon"
    } else {
        # For non-macOS platforms, use the original binary name
        $BinaryFile.BaseName
    }
    
    # Construct a clean name for the final zip archive.
    # e.g., wintree_v0.2.0_windows_amd64.zip or wintree_v0.2.0_macos_silicon.zip
    $ArchiveName = "wintree_$($Version)_$($PlatformName).zip"
    $ArchivePath = Join-Path -Path $DistPath -ChildPath $ArchiveName

    Write-Host "  -> Zipping $($BinaryFile.Name) into $($ArchiveName)..."
    Compress-Archive -Path $BinaryFile.FullName -DestinationPath $ArchivePath -Force
}


# --- 5. Cleanup Raw Binaries ---
Write-Host "🗑️  Cleaning up raw binary files..." -ForegroundColor Yellow
# Delete the original executables, leaving only the .zip files.
Get-ChildItem -Path $DistPath -Exclude "*.zip" | Remove-Item


# --- Final Summary ---
Write-Host ""
Write-Host "✅ Build and packaging complete for wintree $Version!" -ForegroundColor Green
Write-Host "Your release artifacts are ready in the '$DistPath' folder."
Write-Host "You can now upload these .zip files to your GitHub Release page."


